<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
   <title>ephjos</title>
   <description>software development, small projects, and other thoughts</description>
   <language>en-us</language>
   <link>http://ephjos.io/blog/feed.xml</link>
   <atom:link href="http://ephjos.io/blog/feed.xml" rel="self" type="application/rss+xml" />


      <item>
        <title>Advent of Code 2021</title>
        <link>http://ephjos.io/blog/2021/12/01</link>
        <guid>http://ephjos.io/blog/2021/12/01</guid>
        <pubDate>Wed, 01 Dec 2021 12:00:00 -0500</pubDate>
        <description><![CDATA[
                <p>           Its about that time of year,           <a href="https://adventofcode.com/">Advent of Code is back</a>!           I'll be updating this post with my           thoughts and any visualizations           throughout the challenge. The full source for my solutions           can be found           <a href="https://github.com/ephjos/aoc/tree/master/y2021">in this git repo</a>.           I'm taking this year on using Rust, but I may have to switch to           Python later if Rust is slowing me down too much.         </p>          <div>           <h3>Day 01</h3>           <p>             Today was a good start! The problem was fairly standard and simple,             expected for the first day. Turns out I remember almost nothing             about how to use the Rust standard library and I had to lookup             how to get the length of a vector (its <code>.len()</code>).           </p>           <h4>Part 1</h4>           <p>             Iterate over the list of provided numbers, keeping track of             the previous (initialized to the MAX value), and increment a counter             every time the current number is greater than the previous.           </p>           <h4>Part 2</h4>           <p>             Convert the input lines into a vector, converting to integers along             the way. From 2 to the length of the vector, iterate while             keeping track of the previous sum, and increment a counter             every time             the current window <code>v[i-2] + v[i-1] + v[i]</code> is             greater than the previous.           </p>         </div>          <div>           <h3>Day 02</h3>           <p>             This was another standard AOC problem, I think every year has             several "grid movement from commands" types of problems.           </p>           <h4>Part 1</h4>           <p>             Keep track of x position and depth.             For each line of the input, split out the command and its value.             Based on the command, increment/decrement the correct values.             Multiply x and depth at the end.           </p>           <h4>Part 2</h4>           <p>             Same as above but now up and down modify a new variable instead             of depth, aim.             Now, when moving forward, we update depth using aim and the             current value. Multiply x and depth to get the answer.           </p>         </div>          <div>           <h3>Day 03</h3>           <p>             Today was a grind. I could not shake the feeling that I was             missing an obvious bit manipulation trick, but I eventually             went on to using strings and vectors.           </p>           <h4>Part 1</h4>           <p>             Loop over all of the numbers, keeping count of how which digit             occurred more in each column. Go over the counts, and construct             the bits back into two integers before multiplying them and             returning the result.           </p>           <h4>Part 2</h4>           <p>             The strategy here was iteratively remove numbers from the list             until one was remaining. Each iteration would calculate the             digit counts and then remove all rows that did not match the             key so far. Do this for the first and second rule before             multiplying them and returning.           </p>         </div>          <div>           <h3>Day 04</h3>           <p>             Today was a mess. I am not experienced enough with parsing in Rust,             and today's puzzle format amplified that. I also made the mistake             of trying to mutate a struct/vec in a loop while using its iterator.             This can't be done since it would require 2 mutable references             to be alive at the same time. The easy solution is to fallback             to a simple for loop that iterates an integer over the length of             the array, then getting a mutable reference for each element on             every iteration.           </p>           <h4>Part 1</h4>           <p>             Parse out the draws and boards. Created a board struct with 2             methods. Iterate over the list of draws. For each draw, iterate over             all boards. For each board, mark off (set to -1) the draw then             check for Bingo. If there is a bingo, get the sum of all values             that aren't -1 and multiply this sum by the draw number before             returning.           </p>           <h4>Part 2</h4>             Parse out the draws and boards. Created a board struct with 2             methods. Iterate over the list of draws. For each draw, iterate over             all boards. For each board, mark off (set to -1) the draw then             check for Bingo. If there is a bingo and there are other boards             remaining, remove the board from the board list. If there is a             bingo and this is the last board, return its score.           </p>         </div>          <div>           <h3>Day 05</h3>           <p>             Today wasn't bad at all! Parsing the input was straightforward             and the problem itself was fine. I had some hiccups with using             HashMaps in Rust, but didn't have any issues once I refreshed my             knowledge on them.           </p>           <h4>Part 1</h4>           <p>             Parse out each line into a start and end point. For each pair,             skip if they are not on the same line. Then, iterate over the line             and add each point to a <code>HashMap<Point2d, usize></code> to             count how many times we see the point. At the end, return             the number of values in the hashmap that have a count greater             than 1.           </p>           <h4>Part 2</h4>           <p>             Same as above except for non-linear points, connect             them with a line of slope 1 or -1, which can be determined by             looking at their difference.           </p>         </div>          <div>           <h3>Day 06</h3>           <p>             This puzzle was one of my favorite types of AOC problems, where             part2 is just part1 but scaled up. This usually involves some kind             of exponential growth and greatly punishes the naive approach.             I suspect there is a straight numerical solution (this whole thing             screams rings), but I'll search for that later since my solution is             more than fast enough.           </p>           <h4>Part 1</h4>           <p>             I back-ported my solution for part 2 here, but I initially             implemented the naive approach. Parse the list of input numbers             into a vector. For 80 iterations, look at each element in the fish             age list. If the current age is 0, set it back to 6 and add a fish             to the end with age 8. Otherwise, decrement the current age.             Return the length of this array.           </p>           <h4>Part 2</h4>           <p>             Instead of keep a list of fish directly, I instead chose to keep             two lists, fish and new_fish. These vectors have length 7 and 9             respectively with the value representing the number of fish             at the age represented by the index. So if <code>fish[2] = 12</code>             that means there are 12 2-day old fish. Using this, I can             simply move over these vectors and "slide down" the groups of fish.             I keep 2 separate lists due to the different age resets: a new             fish starts at 8 and an old fish starts at 6. We perform the             same shuffle and add between these lists in each loop before             returning the sum of their sums.           </p>         </div>          <div>           <h3>Day 07</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 08</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 09</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 10</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 11</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 12</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 13</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 14</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 15</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 16</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 17</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 18</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 19</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 20</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 21</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 22</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 23</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 24</h3>           <p></p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>          <div>           <h3>Day 25</h3>           <p>Merry Christmas!</p>           <h4>Part 1</h4>           <h4>Part 2</h4>         </div>  
        ]]></description>
      </item>
    

</channel>
</rss>

