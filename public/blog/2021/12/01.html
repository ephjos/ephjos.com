<!DOCTYPE html>
<html lang="en">

  <head>
    <!--#include file="/.shared/head.html" -->
    <title>Advent of Code 2021 - ephjos</title>
  </head>

  <body>
    <!--#include file="/.shared/nav.html" -->
    <main>
      <span>2021/12/01</span>
      <h2>Advent of Code 2021</h2>

      <section>
        <p>
          Its about that time of year,
          <a href="https://adventofcode.com/">Advent of Code is back</a>!
          I'll be updating this post with my
          thoughts and any visualizations
          throughout the challenge. The full source for my solutions
          can be found
          <a href="https://github.com/ephjos/aoc/tree/master/y2021">in this git repo</a>.
          I'm taking this year on using Rust, but I may have to switch to
          Python later if Rust is slowing me down too much.
        </p>

        <div>
          <h3>Day 01</h3>
          <p>
            Today was a good start! The problem was fairly standard and simple,
            expected for the first day. Turns out I remember almost nothing
            about how to use the Rust standard library and I had to lookup
            how to get the length of a vector (its <code>.len()</code>).
          </p>
          <h4>Part 1</h4>
          <p>
            Iterate over the list of provided numbers, keeping track of
            the previous (initialized to the MAX value), and increment a counter
            every time the current number is greater than the previous.
          </p>
          <h4>Part 2</h4>
          <p>
            Convert the input lines into a vector, converting to integers along
            the way. From 2 to the length of the vector, iterate while
            keeping track of the previous sum, and increment a counter
            every time
            the current window <code>v[i-2] + v[i-1] + v[i]</code> is
            greater than the previous.
          </p>
        </div>

        <div>
          <h3>Day 02</h3>
          <p>
            This was another standard AOC problem, I think every year has
            several "grid movement from commands" types of problems.
          </p>
          <h4>Part 1</h4>
          <p>
            Keep track of x position and depth.
            For each line of the input, split out the command and its value.
            Based on the command, increment/decrement the correct values.
            Multiply x and depth at the end.
          </p>
          <h4>Part 2</h4>
          <p>
            Same as above but now up and down modify a new variable instead
            of depth, aim.
            Now, when moving forward, we update depth using aim and the
            current value. Multiply x and depth to get the answer.
          </p>
        </div>

        <div>
          <h3>Day 03</h3>
          <p>
            Today was a grind. I could not shake the feeling that I was
            missing an obvious bit manipulation trick, but I eventually
            went on to using strings and vectors.
          </p>
          <h4>Part 1</h4>
          <p>
            Loop over all of the numbers, keeping count of how which digit
            occurred more in each column. Go over the counts, and construct
            the bits back into two integers before multiplying them and
            returning the result.
          </p>
          <h4>Part 2</h4>
          <p>
            The strategy here was iteratively remove numbers from the list
            until one was remaining. Each iteration would calculate the
            digit counts and then remove all rows that did not match the
            key so far. Do this for the first and second rule before
            multiplying them and returning.
          </p>
        </div>

        <div>
          <h3>Day 04</h3>
          <p>
            Today was a mess. I am not experienced enough with parsing in Rust,
            and today's puzzle format amplified that. I also made the mistake
            of trying to mutate a struct/vec in a loop while using its iterator.
            This can't be done since it would require 2 mutable references
            to be alive at the same time. The easy solution is to fallback
            to a simple for loop that iterates an integer over the length of
            the array, then getting a mutable reference for each element on
            every iteration.
          </p>
          <h4>Part 1</h4>
          <p>
            Parse out the draws and boards. Created a board struct with 2
            methods. Iterate over the list of draws. For each draw, iterate over
            all boards. For each board, mark off (set to -1) the draw then
            check for Bingo. If there is a bingo, get the sum of all values
            that aren't -1 and multiply this sum by the draw number before
            returning.
          </p>
          <h4>Part 2</h4>
            Parse out the draws and boards. Created a board struct with 2
            methods. Iterate over the list of draws. For each draw, iterate over
            all boards. For each board, mark off (set to -1) the draw then
            check for Bingo. If there is a bingo and there are other boards
            remaining, remove the board from the board list. If there is a
            bingo and this is the last board, return its score.
          </p>
        </div>

        <div>
          <h3>Day 05</h3>
          <p>
            Today wasn't bad at all! Parsing the input was straightforward
            and the problem itself was fine. I had some hiccups with using
            HashMaps in Rust, but didn't have any issues once I refreshed my
            knowledge on them.
          </p>
          <h4>Part 1</h4>
          <p>
            Parse out each line into a start and end point. For each pair,
            skip if they are not on the same line. Then, iterate over the line
            and add each point to a <code>HashMap<Point2d, usize></code> to
            count how many times we see the point. At the end, return
            the number of values in the hashmap that have a count greater
            than 1.
          </p>
          <h4>Part 2</h4>
          <p>
            Same as above except for non-linear points, connect
            them with a line of slope 1 or -1, which can be determined by
            looking at their difference.
          </p>
        </div>

        <div>
          <h3>Day 06</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 07</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 08</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 09</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 10</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 11</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 12</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 13</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 14</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 15</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 16</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 17</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 18</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 19</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 20</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 21</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 22</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 23</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 24</h3>
          <p></p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

        <div>
          <h3>Day 25</h3>
          <p>Merry Christmas!</p>
          <h4>Part 1</h4>
          <h4>Part 2</h4>
        </div>

      </section>
    </main>

    <!--#include file="/.shared/footer.html" -->
  </body>
</html>
