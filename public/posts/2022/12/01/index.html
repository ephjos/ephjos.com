<!DOCTYPE html>
<html lang="en">

  <head>
    <!--#include file="/.shared/head.html" -->
    <title>Advent of Code 2022 - ephjos</title>
  </head>

  <body>
    <!--#include file="/.shared/nav.html" -->
    <main>
      <span>2022/12/01</span>
      <h2>Advent of Code 2022</h2>

      <section>
        <p>
          <a href="https://adventofcode.com/">Advent of Code is back</a>!
          I'll be updating this post with my
          thoughts on each day
          throughout the challenge. The full source for my solutions
          can be found
          <a href="https://github.com/ephjos/aoc/tree/master/y2022">in this git repo</a>.
          I was looking into using zig or c this year, but I am going to go
          with python. I think this will be the fastest way for me to complete
          each challenge, which is a priority for me this year.
        </p>

        <div>
          <h3>Day 01</h3>
          <p>
            Today was a typical AoC Day 1. Part 1 was a simple string split on
            <code>"\n\n"</code> and then a max of sums. Part 2 was sorting
            these sums and returning the sum of the 3 largest. I'm happy to
            be kicking things off again this year. As-is, I am pretty happy with
            my template.
          </p>
        </div>
        <div>
          <h3>Day 02</h3>
          <p>
            These problems were straightforward, but my solution was a bit of
            a mess. The key insight (I think) is to map the input chars to
            their numbers and then perform arithmetic with modulus 3 on the
            result. I think this would give the answers in the cleanest way
            possible, but I know that I always struggle with 1-indexed
            modulus, so I wrote out some extra if statements that I
            was sure are correct. I managed to get ranks 1270 and 858
            respectively, which I am happy about. Maybe I'll polish
            this solution up in the morning.
          </p>
        </div>
        <div>
          <h3>Day 03</h3>
          <p>
            This was one of those days where I did not see an obvious easy
            answer until I was working on the second part: use set
            intersections. Once I realized this, I refactored my part 1 and
            it seems to read a bit better. Also, I'm sure there is an easier
            way to map from chars to "type", but I used a dict in my
            implementation. I enjoyed these 2 problems.
          </p>
        </div>
        <div>
          <h3>Day 04</h3>
          <p>
            Another day where sets come to the rescue! I was initially going
            to use a simple dataclass to track each range, but I realized
            that sets may be a better choice. The first part was checking
            for supersets and the second part was checking if the
            intersection was non-null. I complicated things for myself
            by insisting on using a list comprehension to parse the input,
            which is something I don't like doing: but I got the problem
            solved fairly quickly. Today was fun!
          </p>
        </div>
        <div>
          <h3>Day 05</h3>
          <p>
            This was a good problem, but I did not sort out the parsing
            as fast as I would have liked. I went down the path of trying
            to split the input strings from the start, when I should
            have thought for a moment first: using direct string
            indices works better. I figured we wouldn't have a scaling
            issue in part 2 as this is only day 5, so I went ahead
            and implemented the stacks as described in the
            problem. For part 2, I pushed to a temporary stack
            during the swap and then pushed to the destination pile in
            reverse. I could have done this in a different way, but I was
            confident I would get this approach correct faster.
          </p>
        </div>
        <div>
          <h3>Day 06</h3>
          <p>
            At first, I tried to do this a responsible way and track the value
            of each character, returning early when the marker was found. After
            a few minutes of issues with this, I went with the obvious
            approach for me. This was to iterate over the whole input string
            and check if every window of 4 characters was unique. I
            did this by constructing a set and checking if the length was still
            4. While this is likely not the best performance-wise, thanks to the
            string slice and set construction, it was the easiest to write.
            And today's part 2 was a simple extension of the problem, growing
            the window from 4 to 14. Instead of challenging runtime,
            this tweak challenges how easily adaptable the part 1 code was,
            which I think is interesting. For me, I copy/pasted the part 1
            answer and change the 4's to 14's: which was all I needed to do.
            I enjoyed today's problems!
          </p>
        </div>
        <div>
          <h3>Day 07</h3>
          <p>
            Today was a bit of a struggle. The problem itself was not too
            complex, I simply could not come up with a good data structure
            to represent the problem. Days like these are the most
            challenging for me. I ended restarting 30 minutes in and
            cramming everything into nested dictionaries. I then used
            a recursive walk to calculate the directory sizes. The
            end instructions for the final sum were a bit confusing, but
            I was eventually able to work them out. Thankfully, part 2
            only modified the final calculation and did not
            introduce a larger scale change. I need to brush up on my tree
            representations and read about more elegant ways
            to parse this input and represent it in memory.
          </p>
        </div>
        <div>
          <h3>Day 08</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 09</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 10</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 11</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 12</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 13</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 14</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 15</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 16</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 17</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 18</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 19</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 20</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 21</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 22</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 23</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 24</h3>
          <p>Notes go here...</p>
        </div>
        <div>
          <h3>Day 25</h3>
          <p>Notes go here...</p>
        </div>
      </section>
    </main>

    <!--#include file="/.shared/footer.html" -->
  </body>
</html>
