<!DOCTYPE html>
<html lang="en">

  <head>
    {{HEAD}}

    <style>
.container {
  position: relative;
  display: block;
  width: 100%;
  height: 100%;
}
canvas {
  display: block;
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
}
#overlay {
  position: absolute;
  left: 10px;
  top: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  font-family: monospace;
  font-size: 0.8em;
  padding: 0.75em 1em;
}
#overlay:empty {
  padding: 0;
}
#overlay b {
  font-weight: 900;
}
    </style>
    <script src="./index.js" defer></script>
    <title>ray tracing in a weekend</title>
  </head>

  <body>
    {{NAV}}
    <main>
      <table>
        <tr>
          <td class="shrink">2022/04/03</td>
          <td>ray tracing in a weekend</td>
        </tr>
      </table>

      <section>
        <p>
          I have been distracted with a few things, mostly playing around with
          WebGL. I was pulled down the
          <a href="https://www.shadertoy.com/">ShaderToy</a> rabbit hole and
          have been playing around with all kinds of ideas. Most notably, I
          implemented the
          <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">
            Ray Tracing in One Weekend</a> project in a fragment shader, which
          you will see below. I learned quite a bit about WebGL, passing data
          to shaders, and pseudo-random number generation in shaders. The below
          example uses a fixed canvas size of 256x256, stretched with CSS. There
          are 73 balls placed randomly in the scene each time that the shader
          is compiled, which happens every page load. All of the objects are
          written as constant structs into the shader, and the main loop
          is unrolled. The compiled shader is
          logged to the console. Each ray is allowed to bounce 50 times. Also,
          this appears to be a path tracer (to my understanding), since we are
          taking random rays when we bounce, instead of the exact reflection.
          I implemented some basic WebGL abstractions
          and the progressive rendering using some of the logic in
          <a href="https://github.com/evanw/webgl-path-tracing">
            evanw's webgl-path-tracing</a>.
        </p>

        <div class="container">
          <canvas id="glcanvas" width="256" height="256"></canvas>
          <div id="overlay">
            <div id="size"></div>
            <div id="fps"></div>
            <div id="frame"></div>
          </div>
          <div></div>
        </div>

        <p>
          I also found
          <a href="https://github.com/sschoenholz/WebGL-Raytracer">
            sschoenholz's WebGL-Raytracer</a> which does some cool texture
          packing to pass the scene information to the shader.
        </p>

        <p>
          All-in-all, I learned quite a bit about WebGL, raytracing, and path
          tracing which makes me interested in doing more. I am not interested in
          trying to add anymore complex features to my existing python
          implementation of the Ray Tracer Challenge, so I think it is
          time for a rewrite in a lower-level language.
        </p>
      </section>
    </main>
  </body>
  {{END}}
</html>

